% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/genoPlotR.R
\name{plot_gene_map}
\alias{plot_gene_map}
\title{Plot gene and genome maps}
\usage{
plot_gene_map(
  dna_segs,
  comparisons = NULL,
  tree = NULL,
  tree_width = NULL,
  tree_branch_labels_cex = NULL,
  tree_scale = FALSE,
  legend_column = NULL,
  legend_labels = NULL,
  legend_colors = NULL,
  annotations = NULL,
  annotation_height = 0.1,
  annotation_cex = 0.8,
  seg_plots = NULL,
  seg_plot_height = 3,
  seg_plot_height_unit = "lines",
  seg_plot_yaxis = 3,
  seg_plot_yaxis_cex = scale_cex,
  region_size = NULL,
  xlims = NULL,
  print_xlims = FALSE,
  outfile_xlims = NULL,
  offsets = NULL,
  print_offsets = FALSE,
  minimum_gap_size = 0.03,
  fixed_gap_length = FALSE,
  limit_to_longest_dna_seg = TRUE,
  main = NULL,
  main_pos = "centre",
  dna_seg_labels = NULL,
  dna_seg_label_cex = 0.9,
  dna_seg_label_col = "black",
  gene_type = NULL,
  arrow_head_len = 200,
  dna_seg_line = TRUE,
  scale = TRUE,
  dna_seg_scale = FALSE,
  n_scale_ticks = 7,
  scale_cex = 0.6,
  global_color_scheme = NULL,
  color_scheme_column = "auto",
  color_scheme_colors = "auto",
  color_scheme_dataset = "auto",
  gradient_scheme_direction = "auto",
  alpha_dna_segs = NULL,
  alpha_comparisons = NULL,
  plot_new = TRUE,
  outfile = NULL,
  outfile_format = "pdf",
  outfile_height = "auto",
  outfile_width = "auto",
  debug = 0,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{dna_segs}{A list of \code{dna_seg} objects. Mandatory.}

\item{comparisons}{A list of \code{comparison} objects. If provided, they will
plotted between the \code{dna_segs}. The number of \code{comparisons} should be 1 less
than the number of \code{dna_segs}.}

\item{tree}{A tree, in the form of a \link{phylog} object. If provided, will be
plotted on the left. See details.}

\item{tree_width}{A single numeric, giving the width of the tree area in
the plot, in inches. By default it will take 20\% of the total plotting area.}

\item{tree_branch_labels_cex}{A single numeric, giving a size
multiplier for possible node annotations of the provided tree (if present).}

\item{tree_scale}{Logical. If \code{TRUE}, plots a scale for the tree.}

\item{legend_column}{A character string, must be either \code{"auto"}, or refer to
the name of a column present in each \code{dna_seg}. When provided, will attempt
to create a plot legend based on the given column. See details.}

\item{legend_labels}{A character vector of labels to display in the legend.
See details.}

\item{legend_colors}{A character vector of colors to use for the legend, but
only when \code{legend_labels} is provided. See details.}

\item{annotations}{An \code{annotation} or a list of \code{annotation} objects with
the same length as \code{dna_segs}. If provided, plots annotations above the
\code{dna_seg}(s).}

\item{annotation_height}{A single numeric, giving the height reserved
for plotting \code{annotations}. For comparison, the height of a \code{dna_seg} is 1.}

\item{annotation_cex}{A single numeric, giving a size multiplier for the
annotations.}

\item{seg_plots}{A \code{seg_plot} or a list of \code{seg_plot} objects with the same
length as \code{dna_segs}. If provided, plots additional data above the
\code{dna_segs}. See \link{seg_plot} for more information and some examples.}

\item{seg_plot_height}{A single numeric, giving the height of the \code{seg_plot}
regions, measured in the unit provided by \code{seg_plot_height_unit}.}

\item{seg_plot_height_unit}{The unit of the height of the \code{seg_plot} regions.
Must be a valid unit, see the \code{grid} documentation for more details. If
this argument is set to \code{"null"}, then the height will be calculated as a
proportion of the \code{comparison} region (i.e. 0.5 means the \code{seg_plot} region
will be half the size of a \code{comparison}).}

\item{seg_plot_yaxis}{Can be \code{NULL}, \code{FALSE} or a numeric. In the first two
cases, no y-axis is drawn for the \code{seg_plots}. If numeric, an axis is drawn
with approximately that number of ticks.}

\item{seg_plot_yaxis_cex}{A single numeric, giving a size multiplier for the
\code{seg_plot} y-axis.}

\item{region_size}{A single numeric or numeric vector with the same length
as \code{dna_segs}, providing the neighbourhood size to use for creating regional
plots. Ignored if \code{xlims} are provided. See details.}

\item{xlims}{A list with as many elements as there are \code{dna_segs}, or
\code{NULL}. If \code{NULL}, the whole DNA segment will be represented. If a list is
provided, each element of the list must be a numeric vector, representing
pairs of left and right limits for each subsegment. See details.}

\item{print_xlims}{Logical. If \code{TRUE}, prints out the \code{xlims} (start and
end coordinates of each subsegment of each \code{dna_seg}).}

\item{outfile_xlims}{A file path. If provided, the \code{xlims} (start and
end coordinates of each subsegment of each \code{dna_seg}) are written to this
file.}

\item{offsets}{A list or numeric vector with the same length as \code{dna_segs},
or \code{NULL}, giving the distance before and between subsegments. Each element
of this list must be the same length as the number
of subsegments (see \code{xlims} and details). If \code{offsets} is \code{NULL}, then the
gaps are optimized to minimize \code{comparison} length. See details.}

\item{print_offsets}{Logical. If \code{TRUE}, prints out the \code{offsets}, the gap
lengths between subsegments for each \code{dna_seg}.}

\item{minimum_gap_size}{A single numeric, giving the minimum gap size
between subsegments, proportional to the plot region (e.g. \code{0.03} means the
width of the gaps will be at least 3\% of the overall plot width).}

\item{fixed_gap_length}{Logical. If \code{TRUE}, then the gaps between
subsegments will all have the same fixed length instead of optimizing the
gap size to minimize \code{comparison} length.}

\item{limit_to_longest_dna_seg}{Logical. If \code{TRUE}, restricts the plot width
to the length of the longest \code{dna_seg}. If \code{FALSE}, the sizes of the shorter
\code{dna_segs} can be extended to better fit the \code{comparisons}, but this can
lead to extremely wide plots.}

\item{main}{A character string that gives the main title of the plot.}

\item{main_pos}{A character string that gives the position of the plot title.
Must be one of \code{"centre"}, \code{"left"}, or \code{"right"}.}

\item{dna_seg_labels}{A character vector with the same length as \code{dna_segs},
or \code{NULL}. If \code{NULL}, the names of the \code{dna_segs} will be determined
automatically where possible (e.g. if \code{dna_segs} is a named list). Labels
are optional, but must be provided or findable if a tree is provided.}

\item{dna_seg_label_cex}{A single numeric, giving a size multiplier for the
\code{dna_seg} labels.}

\item{dna_seg_label_col}{A character vector, providing the color(s) for the
\code{dna_seg} labels. Must provide either 1 color or as many as there are
\code{dna_segs}.}

\item{gene_type}{A character string, determines the gene type (i.e. shape)
of the features, overriding the \code{gene_type} column of the \code{dna_segs}.
See \link{gene_types}.}

\item{arrow_head_len}{A single numeric, giving the length of the arrow heads
for the \code{"arrows"} and \code{"headless_arrows"} gene types. At maximum, the arrow
heads extend to half of the total length. Can be set to \code{Inf} to force this
behavior.}

\item{dna_seg_line}{A vector, either logical or character, with a length of
either 1 or the amount of \code{dna_segs}. Determines whether a line should be
drawn through the middle of each \code{dna_seg}, and if so, what color. See
details.}

\item{scale}{Logical. If \code{TRUE}, a scale will be displayed on the plot.}

\item{dna_seg_scale}{A single logical that determines whether a scale
should be drawn under each \code{dna_seg}, or a logical vector of the same
length as \code{dna_segs}, for making this choice for each \code{dna_seg} separately.}

\item{n_scale_ticks}{A single numeric, giving the approximate number of
ticks to display on the longest segment.}

\item{scale_cex}{A single numeric, giving a size multiplier for the scale
labels.}

\item{global_color_scheme}{A character string, adding a color scheme to
the \code{dna_segs} and/ or \code{comparisons}. Must be one of: \code{"uniform"},
\code{"gradient"}, or \code{"sequential"}. See details.}

\item{color_scheme_column}{A character string, must be either \code{"auto"}, or
refer to the name of a column. Depending on \code{global_color_scheme}, the colors
will be determined based on the values found in this column. See details.}

\item{color_scheme_colors}{A color scheme. If
\code{global_color_scheme = "gradient"}, then it must be one of: \code{"red_blue"},
\code{"blue_red"}, or \code{"gray"}. If \code{global_color_scheme = "uniform"}, it can be
a palette or vector of colors to use. See details.}

\item{color_scheme_dataset}{A character string, a choice of which data to
apply the color scheme to. Must be one of: \code{"auto"}, \code{"dna_segs"}, or
\code{"comparisons"}. If \code{"auto"}, the color scheme will be applied to both,
unless it is not possible to apply it to the \code{comparisons}. Only applies
when \code{global_color_scheme} is \code{"uniform"} or \code{"sequential"}.}

\item{gradient_scheme_direction}{A character string, indicating the
direction of the scale used in the gradient color scheme. Must be one of:
\code{"increasing"}, \code{"decreasing"}, or \code{"auto"}. See details.}

\item{alpha_dna_segs}{A single numeric value between 0 and 1, or \code{NULL}.
Determines the transparency applied to the \code{dna_segs}, 0 being fully
transparent, and 1 being fully opaque. This overrides any existing alpha
values. If \code{NULL}, no change is made.}

\item{alpha_comparisons}{A single numeric value between 0 and 1, or \code{NULL}.
Determines the transparency applied to the \code{comparisons}, 0 being fully
transparent, and 1 being fully opaque. This overrides any existing alpha
values. If \code{NULL}, no change is made.}

\item{plot_new}{Logical. If \code{TRUE}, uses \code{grid.newpage()} to produce a new
plot. If \code{FALSE}, integrates it on the current plot.}

\item{outfile}{A file path. If provided, the plot will be saved to this
file instead of the regular output.}

\item{outfile_format}{A character string, giving the file format for the
saved plot \code{outfile}. Must be one of: \code{"pdf"}, \code{"png"}, or \code{"bmp"}.}

\item{outfile_height}{A single numeric, giving the height of the plot
\code{outfile} in inches, or \code{"auto"}. If \code{"auto"}, an appropriate height will be
approximated automatically.}

\item{outfile_width}{A single numeric, giving the width of the plot
\code{outfile} in inches, or \code{"auto"}. If \code{"auto"}, an appropriate width will be
approximated automatically.}

\item{debug}{A numeric. If larger than \code{0}, only that number of elements
will be plotted for each \code{dna_seg} and \code{comparison}.}

\item{verbose}{Logical. If \code{TRUE}, reports the timing of various steps.}

\item{...}{Further arguments to be passed to user-defined graphical
functions.}
}
\value{
A lattice graphic is plotted on the current device. The function
itself returns nothing (invisible \code{NULL}).
}
\description{
This plotting function represents linear DNA segments and comparisons
between them. It will plot one line per DNA segment, eventually separated
by the comparisons. In addition, a tree can be plotted on the left of the
plot, as well annotations on each DNA segment. This function is based on the
grid package, and as such the plots can be placed into
other graphics or modified.
}
\details{
One line is plotted per \code{dna_seg}. The shape of the \code{dna_seg} elements is
determined by the \code{gene_type} column, unless they are explicitly overwritten
using the \code{gene_type} argument. See \link{gene_types} for more details.  When
provided, \code{comparisons} are placed
in between the \code{dna_segs}, annotations are displayed above each \code{dna_seg},
and accompanying data for each \code{dna_seg} can be plotted using \code{seg_plots}
(see \link{seg_plot} for more details).

A phylogenetic tree (a \code{phylog} object from package \code{ade4}) can be drawn at
the left of the plot (see \link{newick2phylog}). The tree does not need to be
ordered in the same way as the \code{dna_seg_labels}, but a permutation of the
tree with that order should exist. If the tree is large, the number of
permutations can become too large, causing the function to stop
(>100000 permutations). The solution is then to provide \code{dna_segs} that are
ordered in the same manner as the tree labels, or vice-versa (see
\link{permute_dna_segs}). There is (experimental) support for branch annotations.
These are given in the Newick tree, directly after the parenthesis closing a
node. They can be characters or integers, but so far \link{newick2phylog} does
not support the \code{.} character in any labels. Tags will be ignored if they
start with "I", and trimmed if they start with "X".

There are two ways to draw a legend using this function:

The first is a
customizable legend, which can be drawn by providing a vector of labels to
the \code{legend_labels} argument and a vector of colors to link to these labels
to the \code{legend_colors} argument.

The other way is through the \code{legend_column}
argument, which must be \code{"auto"}, or the name of a column present in each
\code{dna_seg}. If \code{"auto"}, the column to use will be the same as the column
that was used for the \code{"uniform"} color scheme if this was applied, the
\code{gene} column if this was present, or finally the \code{name} column if neither
of the previous options are possible. The legend will take all possible
values for the chosen column, alongside the color of the first instance it
can find for each possible value. If \code{legend_labels} was provided, only
values found in that character vector are considered for the legend.

The \code{xlims} allow the user to plot subsegments of a \code{dna_seg}. \code{xlims}
consists of a list composed of as many numeric vectors as there are
\code{dna_segs}. Each of these numeric vectors give pairs of left and right
borders, and gives the direction. For example, \code{c(1,2,6,4)} will plot two
subsegments for a single \code{dna_seg}, the first subsegment will go from 1 to 2
which is plotted left to right and the second subsegment will go from 4 to 6,
plotted right to left. \code{-Inf} and \code{Inf} values are accepted. \code{NULL} values
will result in plotting the whole segment.

Alternatively, the \code{region_size} argument can be used to make regional plots
in a more automated fashion. Any \code{dna_seg} features with the value \code{"TRUE"}
in their \code{region_plot} column will be plotted and become the center of a
subsegment. Portions of the \code{dna_seg} to the left and right of these features
will be included and the size of these portions is determined by
\code{region_size}. Any overlapping subsegments will be merged, and features
marked as \code{boundaries} will end subsegments early (e.g. chromosome or contig
boundaries). Functions like \link{edit_dna_segs} can be used to alter which
features to focus on by altering the \code{region_plot} column, but \code{dna_segs}
can be altered in the same manner as \code{data.table} objects as well, see the
\code{data.table} package for more details.

\code{offsets} allows the user to define the placement of the subsegments
(as defined by \code{xlims} or \verb{region_size). If  }offsets\verb{is a list, each element represents 1}dna_seg\verb{and must be a numeric vector giving gap sizes between the subsegments of that}dna_seg\verb{, including the first one (which will be the distance between the left border of the plot and the first subsegment). Each element of this list must be the same length as the number of subsegments (see }xlims\verb{and details). If}offsets\verb{is a numeric vector, then those numbers will give the distance before the first subsegment for each}dna_seg\verb{, while the others gaps remain static.  If }offsets\code{is }NULL\verb{, then the gaps are optimized to minimize }comparison` length.

\code{dna_seg_line} determines whether a line should be drawn through each
\code{dna_seg}, and if so, what color. If only value is provided, then this
value will be repeated for each \code{dna_seg}. If \code{dna_seg_line} is a logical
vector, \code{TRUE} will default to drawing a black line for that \code{dna_seg},
and \code{FALSE} will result in no line. If \code{dna_seg_line} is a character vector,
\code{"FALSE"} will still result in no line, but any other value will be
interpreted as a color choice for the line.

\code{global_color_scheme} applies a color scheme to the \code{dna_segs} and/or
\code{comparisons}, overriding the colors present in those objects. There are 3
options: \code{"uniform"},\code{"gradient"}, and \code{"sequential"}. These color schemes
can be further customized using the other color scheme arguments.
\itemize{
\item \code{"uniform"}: Applies a different color for each possible value of a
given column (specified by \code{color_scheme_column}) from the \code{dna_segs} and/
or \code{comparisons} (specified by \code{color_scheme_dataset}). Only the values
for features shown in the plot are included. The \code{color_scheme_column} must
be a column present in all \code{dna_segs} (\code{comparisons} are skipped if it is
not present there). If \code{color_scheme_column = "auto"}, it will determine
which column to use, prioritizing column names related to orthology and
groups, followed by the \code{gene} column and finally the \code{gene_type} column.
The choice of colors is dependent on the \code{color_scheme_colors} argument.
This can be a color palette, or a character vector of colors recognizable
by R. If \code{color_scheme_colors = "auto"}, a palette will be chosen based on
the amount of distinct colors that are required. See \link{uniform_color_scheme}
for the function that is used to apply this color scheme.
\item \code{"gradient"}: Applies a gradient color scheme to the \code{comparisons}
based on a numerical column (specified by \code{color_scheme_column}) that is
present in all the \code{comparisons}. The gradient is dependent on
\code{color_scheme_colors}, which can be \code{"red_blue"}, \code{"blue_red"}, or \code{"gray"}
(\code{"auto"} will default to \code{"red_blue"}). If \code{color_scheme_column = "auto"},
it will determine which column to use, prioritizing column names that would
be present if the \code{comparisons} were parsed from BLAST results. The
direction of the gradient
is dependent on \code{gradient_scheme_direction}, which should be \code{"increasing"}
for variables that represent a relationship that increases as the numbers
go up (e.g. bit score, alignment length), \code{"decreasing"} for variables that
represent a relationship that decreases as the numbers go up (e.g. e-value,
gaps, mismatches), or \code{"auto"}, which will attempt to determine this
automatically depending on the chosen column. See \link{gradient_color_scheme}
for the function that is used to apply this color scheme.
\item \code{"sequential"}: Transfers over any colors already present in the
\code{dna_segs} and \code{comparisons} and copies them over to linked features.
Features are linked through shared identifiers (specified by
\code{color_scheme_column}) and \code{comparisons} that connect them.
See \link{sequential_color_scheme} for
the function that is used to apply this color scheme.
}
}
\examples{
old.par <- par(no.readonly = TRUE)
data("three_genes")
dna_segs <- three_genes$dna_segs
comparisons <- three_genes$comparisons

## Segments only
plot_gene_map(dna_segs = dna_segs) 

## With comparisons
plot_gene_map(dna_segs = dna_segs, comparisons = comparisons) 

## Tree
names <- c("A_aaa", "B_bbb", "C_ccc")
names(dna_segs) <- names
tree <- ade4::newick2phylog("(((A_aaa:4.2,B_bbb:3.9):3.1,C_ccc:7.3):1);")
plot_gene_map(dna_segs = dna_segs, comparisons = comparisons,
              tree = tree)
## Increasing tree width
plot_gene_map(dna_segs = dna_segs, comparisons = comparisons,
              tree = tree, tree_width = 3)
## Annotations on the tree
tree2 <- ade4::newick2phylog("(((A_aaa:4.2,B_bbb:3.9)97:3.1,C_ccc:7.3)78:1);")
plot_gene_map(dna_segs = dna_segs, comparisons = comparisons,
              tree = tree2, tree_width = 3)
plot_gene_map(dna_segs = dna_segs, comparisons = comparisons,
              tree = tree2, tree_width = 3, tree_branch_labels_cex = 0.6)
plot_gene_map(dna_segs = dna_segs, comparisons = comparisons,
              tree = tree2, tree_width = 3, tree_branch_labels_cex = 0)

## Annotation
## Calculating middle positions
mid_pos <- middle(dna_segs[[1]])

# Create first annotation
annot1 <- annotation(x1 = mid_pos, text = dna_segs[[1]]$name)
plot_gene_map(dna_segs = dna_segs, comparisons = comparisons,
              annotations = annot1)

## Exploring options
annot2 <- annotation(x1 = c(mid_pos[1], dna_segs[[1]]$end[2]),
                     x2 = c(NA, dna_segs[[1]]$end[3]),
                     text = c(dna_segs[[1]]$name[1], "region1"),
                     rot = c(30, 0), col = c("grey", "black"))
plot_gene_map(dna_segs = dna_segs, comparisons = comparisons,
              annotations = annot2, annotation_height = 1.3)

## xlims
## Just reversing 1 segment
plot_gene_map(dna_segs, comparisons,
              xlims = list(NULL, NULL, c(Inf,-Inf)),
              dna_seg_scale = TRUE)
## Removing one gene
plot_gene_map(dna_segs, comparisons,
              xlims = list(NULL, NULL, c(-Inf,2800)),
              dna_seg_scale = TRUE)

## offsets
offsets <- c(0, 0, 0)  
plot_gene_map(dna_segs = dna_segs, comparisons = comparisons,
              offsets = offsets)
offsets <- c(200, 400, 0)  
plot_gene_map(dna_segs = dna_segs, comparisons = comparisons,
              offsets = offsets)

## main
plot_gene_map(dna_segs = dna_segs, comparisons = comparisons,
              main = "Comparison of A, B and C")
plot_gene_map(dna_segs = dna_segs, comparisons = comparisons,
              main = "Comparison of A, B and C", main_pos = "left")

## dna_seg_labels
plot_gene_map(dna_segs = dna_segs, comparisons = comparisons,
              dna_seg_labels = c("Huey", "Dewey", "Louie"))

## dna_seg_labels size
plot_gene_map(dna_segs = dna_segs, comparisons = comparisons,
              dna_seg_labels = c("Huey", "Dewey", "Louie"),
              dna_seg_label_cex = 2)

## dna_seg_line
plot_gene_map(dna_segs = dna_segs, comparisons = comparisons,
              dna_seg_line = c("FALSE", "red", grey(0.6)))

## gene_type
plot_gene_map(dna_segs = dna_segs, comparisons = comparisons,
              gene_type = "side_blocks")

##
## From here on, using a bigger dataset from a 4-genome comparison
##
data("barto")
## Adding a tree
tree <- ade4::newick2phylog("(BB:2.5,(BG:1.8,(BH:1,BQ:0.8):1.9):3);")
## Showing only subsegments
xlims1 <- list(c(1380000, 1445000),
               c(10000, 83000),
               c(15000, 98000),
               c(5000, 82000))
## Reducing dataset size for speed purpose
for (i in 1:length(barto$dna_segs)) {
  barto$dna_segs[[i]] <- trim(barto$dna_segs[[i]], xlim = xlims1[[i]])
  if (i < length(barto$dna_segs)) {
    barto$comparisons[[i]] <- trim(barto$comparisons[[i]],
                                   xlim1 = xlims1[[i]], xlims1[[i+1]])
  }
}
plot_gene_map(barto$dna_segs, barto$comparisons, tree = tree,
              xlims = xlims1,
              dna_seg_scale = TRUE)
## Showing several subsegments per genome
xlims2 <- list(c(1445000, 1415000, 1380000, 1412000),
               c(  10000,   45000,   50000,   83000, 90000, 120000),
               c(  15000,   36000,   90000,  120000, 74000,  98000),
               c(   5000,   82000))
plot_gene_map(barto$dna_segs, barto$comparisons, tree = tree,
              xlims = xlims2,
              dna_seg_scale = TRUE)
## Hand-made offsets: size of all gaps
offsets2 <- list(c(10000, 10000),
                 c(2000, 2000, 2000),
                 c(10000, 5000, 2000),
                 c(10000))
plot_gene_map(barto$dna_segs, barto$comparisons, tree = tree,
              xlims = xlims2,
              offsets = offsets2,
              dna_seg_scale = TRUE)

## dna_seg_scale, global_color_scheme, size, number, color of dna_seg_scale,
## size of dna_seg_scale labels
plot_gene_map(barto$dna_segs, barto$comparisons, tree = tree,
              xlims = xlims2,
              dna_seg_scale = c(TRUE, FALSE, FALSE, TRUE),
              scale = FALSE,
              dna_seg_label_cex = 1.4,
              dna_seg_label_col = c("black", "grey", "blue", "red"),
              global_color_scheme = "gradient",
              alpha_comparisons = 0.5,
              n_scale_ticks = 3, scale_cex = 1)

##
## Exploring and modifying a previously plotted gene map plot
##
plot_gene_map(barto$dna_segs, barto$comparisons, tree = tree,
              xlims = xlims2, offsets = offsets2, dna_seg_scale = TRUE)
## View viewports
current.vpTree()
## Go down to one of the viewports, add an xaxis, go back up to root viewport
downViewport("dna_seg_scale.3.2")
grid.rect()
upViewport(0)
## Get all the names of the objects
grobNames <- getNames()
grobNames
## Change the color of the scale line
grid.edit("scale.lines", gp = gpar(col = "grey"))
## Remove first dna_seg_lines
grid.remove("dna_seg_line.1.1")

##
## Plot genoPlotR logo
##
col_vec <- c("#B2182B", "#D6604D", "#F4A582", "#FDDBC7",
             "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC")
cex <- 2.3
## First segment 
start1 <- c(150, 390, 570, 270, 530)
end1   <- c(  1, 490, 690, 270, 530)
## Second segment
start2 <- c(100, 520, 550, 330)
end2   <- c(240, 420, 650, 330)
## dna_segs
ds1 <- as.dna_seg(data.frame(name = c("", "", "", "geno", "R"),
                             start = start1, end = end1, strand = rep(1, 5),
                             fill = col_vec[c(2, 6, 1, 8, 9)]
                             ))
ds_genoR <- edit_dna_segs(ds1, ids = data.frame(id = c("geno", "R"), 
                                                cex = c(2.3, 2.3),
                                                gene_type = c("text", "text")
                                                ))
ds2 <- as.dna_seg(data.frame(name = c("", "", "", "Plot"),
                             start = start2, end = end2,
                             strand = rep(1, 4),
                             fill = col_vec[c(5, 3, 7, 1)]
                             ))
ds_Plot <- edit_dna_segs(ds2, ids = data.frame(id = "Plot", 
                                               cex = 2.3,
                                               gene_type = "text"
                                               ))
## comparison
c1 <- as.comparison(data.frame(start1 = start1[1:3], end1 = end1[1:3],
                               start2 = start2[1:3], end2 = end2[1:3],
                               fill = grey(c(0.6, 0.8, 0.5))))
## Generate genoPlotR logo
\dontrun{
  pdf("logo.pdf", h = 0.7, w = 3)
}
par(fin = c(0.7, 3))
plot_gene_map(dna_segs = list(ds_genoR, ds_Plot),
              comparisons = list(c1), scale = FALSE, dna_seg_scale = FALSE,
              dna_seg_line = grey(0.7), offsets = c(-20,160))
\dontrun{
  dev.off()
}
par(old.par)

}
\seealso{
\link{dna_seg} and \link{comparison} for the base objects;
\link{read_dna_seg_from_file}, \link{read_comparison_from_file}, and
\link{read_orthogroup_from_file} to read from files; \link{annotation} to annotate
\code{dna_segs}; \link{seg_plot} to draw plots above \code{dna_segs}; \link{gene_types} for
\code{gene_type} argument; \link{uniform_color_scheme}, \link{gradient_color_scheme}, and
\link{uniform_color_scheme} for color schemes
}
\author{
Lionel Guy \verb{<lionel.guy@ebc.uu.se>}, Jens Roat Kultima. Mike Puijk
}
